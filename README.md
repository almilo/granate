# granate

[![npm version](https://badge.fury.io/js/granate.svg)](https://badge.fury.io/js/granate)
[![Build Status](https://travis-ci.org/almilo/granate.svg?branch=master)](https://travis-ci.org/almilo/granate)
[![Coverage Status](https://coveralls.io/repos/github/almilo/granate/badge.svg?branch=master)](https://coveralls.io/github/almilo/granate?branch=master)

Granate container for annotated GraphQL

## Introduction
GraphqQL is an amazing technology that allows to build application APIs in a much better way than by using REST
services. On top of this, GraphQL can be defined using a textual representation (schema language) which offers a lot
of really useful possibilities.

## TL;DR
Imagine that you want to implement a Todo application and you have drafted a GraphQL schema which looks as follows:

```
 # Domain entity which represents a Todo object
 type Todo {
     id: ID!
     title: String!
     completed: Boolean!
 }
 
 # Query model for Todos
 type Query {
     todos(completed: Boolean): [Todo]
 }
 
 # Mutations for Todos
 type Mutation {
     # Adds an uncompleted Todo with the given description
     addTodo(title: String!): Todo!
     # Removes a Todo by id
     removeTodo(id: ID!): Todo!
     # Toggles the completed state of a Todo by id
     toggleTodo(id: ID!): Todo!
 }
```

As of [graphql-js@0.7.0](https://medium.com/apollo-stack/all-you-need-to-know-about-graphql-js-0-7-921e75dd7fd1), by
using the ```buildSchema()``` and ```graphql()``` functions together with an object like the one below as
```rootValue```, it is then possible to execute GraphQL queries and mutations against the object as if it were a
full-fledged GraphQL endpoint.
 
```js
export class Todos {
    constructor() {
        this.nextId = Date.now();
        this.todos = [];
    }

    todos({completed}) {
        return this.todos.filter(completedFilter);

        function completedFilter(todo) {
            return completed === undefined ? todo : todo.completed === completed;
        }
    }

    addTodo({title}) {
        const todo = {
            id: String(this.nextId++),
            title,
            completed: false
        };
        this.todos.push(todo);

        return todo;
    }

    removeTodo({id}) {
        const todo = this.todos.filter(todo => todo.id === id)[0];
        todos.splice(this.todos.indexOf(todo), 1);

        return todo;
    }

    toggleTodo({id}) {
        const todo = this.todos.filter(todo => todo.id === id)[0];
        todo.completed = !todo.completed;

        return todo;
    }
}
```
 
Then you can use this as:
 
```js
import { Todos } from './todos';

const schema = `
# Domain entity which represents a Todo object
type Todo {
... content skipped
`;
const query = `
    { 
        todos {
            title
            completed
        }
    }`;
const todos = new Todos();

graphql(schema, query, todos).then(result => console.log(result)); // prints the query result

```

And if you want to make this API available through HTTP:

```js
import express from 'express';
import graphqlHTTP from 'express-graphql';
import { Todos } from './todos';

const PORT = 4000;
const schema = `
# Domain entity which represents a Todo object
type Todo {
... content skipped
`;
const todos = new Todos();
const graphqlHTTPConfig = createGraphQLHTTPConfig(schema, todos);

express()
    .use('/graphql', graphqlHTTP(graphqlHTTPConfig))
    .listen(PORT, () => console.log(`Listening on port: '${PORT}'...`));

function createGraphQLHTTPConfig(schema, rootValue) {
    return {
        schema,
        rootValue,
        graphiql: true
    };
}
```

Wouldn't it be cool if we could avoid defining the ```rootValue``` implementation and use mock data like the one
generated by [casual](https://github.com/boo1ean/casual) or [faker.js](https://github.com/Marak/faker.js) instead?
This would allow to mock an API just by using a GraphQL schema text file.
Well, we easily can if we use the package
[graphql-tools](https://medium.com/apollo-stack/mocking-your-server-with-just-one-line-of-code-692feda6e9cd).

* But it would be better if we could start with just a plain text file and generic mock data and incrementally
define how the mock data should look like or even which implementation to use as ```rootValue```, isn't it?
* And what if we could use mock data when the root value provides no implementation?
* Couldn't we eventually use a legacy REST API to implement part of the schema?
* And what if we could reuse not only existing REST APIs but also GraphQL endpoints?

... enter Granate!
